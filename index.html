<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" charset="utf-8">
		<link rel="stylesheet" href="./data/style.css" type="text/css">
		<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
		<script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
		<script>
		
		if (navigator.userAgent.match(/iPhone|Android.+Mobile/)) {
			window.addEventListener("load", ()=>{
			    const main = document.querySelector("main");
			 
			    main.addEventListener("touchmove", function(e){
			        // 端末のデフォルト動作をキャンセル
			        e.preventDefault();
			    });
			});
		}

		</script>
		<script>

		const tpCache = [];

		const el = document;
		el.ontouchstart = start_handler;
		el.ontouchmove = move_handler;
		// touchcancel と touchend に同じハンドラーを使用
		el.ontouchcancel = end_handler;
		el.ontouchend = end_handler;

		function handle_pinch_zoom(ev) {
		  if (ev.targetTouches.length === 2 && ev.changedTouches.length === 2) {
		    // 2 つのタッチが、 2 タッチを開始したのと同じタッチかどうかを確認
		    const point1 = tpCache.findLastIndex(
		      (tp) => tp.identifier === ev.targetTouches[0].identifier,
		    );
		    const point2 = tpCache.findLastIndex(
		      (tp) => tp.identifier === ev.targetTouches[1].identifier,
		    );

		    if (point1 >= 0 && point2 >= 0) {
		      // 開始座標と移動座標の差を計算
		      const diff1 = Math.abs(
		        tpCache[point1].clientX - tpCache[point2].clientX,
		      );
		      const diff2 = Math.abs(
		        ev.targetTouches[0].clientX - ev.targetTouches[1].clientX,
		      );
		      pos.z += (diff1 - diff2) * -0.001;
		      // Restrict scale
			  pos.z = Math.min(Math.max(-7, pos.z), -2);

			  // Apply scale transform
			  target.setAttribute('position', pos);
			  
		    } else {
		      // empty tpCache
		      tpCache = [];
		    }
		  }
		}

		function start_handler(ev) {。
		  ev.preventDefault();
		  // 2タッチピンチ/ズームを後で処理するためにタッチ点をキャッシュする
		  if (ev.targetTouches.length === 2) {
		    for (let i = 0; i < ev.targetTouches.length; i++) {
		      tpCache.push(ev.targetTouches[i]);
		    }
		  }  	
		  new_box.setAttribute('color', 'cyan');
		}

		function move_handler(ev) {
		  ev.preventDefault();
		  if (!(ev.touches.length === 2 && ev.targetTouches.length === 2)) {
		  	new_box.setAttribute('color', 'green');
		  }

		  // 2 タッチの移動/ピンチ/ズームジェスチャーでは、このイベントをチェックする
		  handle_pinch_zoom(ev);
		}

		function end_handler(ev) {
		  ev.preventDefault();

		  if (ev.targetTouches.length === 0) {
		  	new_box.setAttribute('color', 'yellow');
		  }
		}

		</script>
		<script>

		AFRAME.registerComponent('cursor-listener', {
    		init: function () {
   		   this.el.addEventListener('raycaster-intersected', evt => {
   		     this.raycaster = evt.detail.el;
   		   });
   		   this.el.addEventListener('raycaster-intersected-cleared', evt => {
   		     this.raycaster = null;
   		   });
  		  },
  		  tick: function () {
  		      if (!this.raycaster) { return; }  // Not intersecting.
  		      let intersection = this.raycaster.components.raycaster.getIntersection(this.el).point;
  		      if (!intersection) { return; } // Not intersecting
  		      // intersecting
  		      new_box.setAttribute('position', intersection);
  		  }
 		 });
		</script>
	</head>
	<body onload="init();" style="touch-action:none">

		<!--3D空間-->
		<a-scene embedded arjs vr-mode-ui="enabled: false;">
			<a-entity camera look-controls="touchEnabled: false;">
				
				<a-entity cursor="rayOrigin: mouse" raycaster="objects: #target;  showLine:true;"></a-entity> <!--移動オブジェクトの移動先の取得-->

				<a-plane cursor-listener id="target" position="0 0 -2" scale="25 15 1" opacity="0"></a-plane> <!--rayの衝突用-->
			</a-entity>
		</a-scene>

		<!--仮UI-->



		<!--JS用-->

		<script src="./data/tutorial.js"></script>
		<script src="./data/rayControll.js"></script>
	</body>
</html>